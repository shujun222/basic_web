<script>
    // 1. 改变构造函数的原型不是继承，还会出错
    function changePrototype() {
        function User() { }
        User.prototype.show = function () {
            console.log("show user name");
        }

        // 1.2 管理员类
        function Admin() { }
        Admin.prototype = User.prototype
        let admin = new Admin();
        admin.show();

        //1.3 会员类
        function Member() {}
        Member.prototype = User.prototype
        let member = new Member()
        member.show();

        // 改变子类原型，可以获取父类User的show方法，暂时没啥问题
        // 然而，给Admin增加了一个角色管理方法
        Admin.prototype.role = function() {
            console.log("admin role");
        }

        // 然后admin, memeber都可以拿到方法了
        admin.role()
        member.role();

    }
    
    // changePrototype();



    // 2. 各自维护原型，原型之间的继承才是继承
    function extendPrototype() {
        // 1. 改变构造函数的原型不是继承，还会出错
        function User() { }
        User.prototype.show = function () {
            console.log("show user name");
        }

        // 1.2 管理员类
        function Admin() { }
        Admin.prototype = User.prototype
        let admin = new Admin();
        admin.show();

        //1.3 会员类
        function Member() {}
        Member.prototype = User.prototype
        let member = new Member()
        member.show();

        // 改变子类原型，可以获取父类User的show方法，暂时没啥问题
        // 然而，给Admin增加了一个角色管理方法
        Admin.prototype.role = function() {
            console.log("admin role");
        }

        // 然后admin, memeber都可以拿到方法了
        admin.role()
        member.role();

    }
    
    extendPrototype();
</script>