<script>
    
    console.dir(Object);
    Object.prototype.show = function() {
        console.log("最顶级对象Object.prototype 中添加方法: show");
        return "haha"
    }
    console.dir(Object);
    // console.log(Object.show()); // ok

    console.log("Object.__proto__ == Function.prototype:", Object.__proto__ == Function.prototype);
    Object.__proto__.show2 = function() {
        console.log("最顶级对象Object.__proto__ 中添加方法: show2");
        return 666
    }
    console.dir(Object);
    console.log(Object.length, Object.keys);
    console.log(Object.show2()); // 也ok？ 直接调用对象的方法，是使用的prototype还是__proto__，还是本身呢？

    let hd = new Object();
    hd.name = "Object 属性 name";
    console.log("hd", hd);    
    console.log("hd.show", hd.show());

    // hd.__proto__.show2 = function() {
    //     console.log("给hd实例的__proto__塞进去一个方法：show2");
    // }

    /**
     * Object.__proto__ 对hd没有效果？对的！
     * 因为 Object.__proto__ 指向的是 Function.prototype, hd是从Object中实例出来的对象，构造函数放在Object.prototype中，
     * hd基本就是copy的Object.prototype，暂时还不知道Object.__proto__干吗用的
     * */
    // console.log("hd.show2", hd.show2());

    console.log("");


    /**
     * 函数的原型链更绕
     * 
     * */
    function User() {}
    console.dir(User);

    // 三个全等什么玄机呢？为什么会失败呢？
    // console.log("User.prototype.__proto__ == User.__proto__.__proto__ == Object.prototype", User.prototype.__proto__ == User.__proto__.__proto__ == Object.prototype );
    console.log("User.prototype.__proto__ == User.__proto__.__proto__ == Object.prototype ", User.prototype.__proto__ == User.__proto__.__proto__ && User.__proto__.__proto__ == Object.prototype );
    console.log("User.__proto__ == Function.prototype", User.__proto__ == Function.prototype);
    console.log("User.__proto__.__proto__ == Object.prototype", User.__proto__.__proto__ == Object.prototype);

    console.log(Function.prototype);
    

</script>